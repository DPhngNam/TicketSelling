name: Deploy to Docker Swarm on EC2 with AWS RDS

on:
  push:
    branches:
      - main # Trigger CD on push to main
  pull_request:
    branches:
      - main # Trigger CI on pull requests to main

env:
  REGISTRY: hub.docker.com # Or docker.io, etc.
  IMAGE_NAME: tqt0304/userservice
  # Name of your stack defined when running 'docker stack deploy'
  SWARM_STACK_NAME: my-prod-stack
  # Path to your compose file ON THE SWARM MANAGER NODE
  COMPOSE_FILE_PATH_ON_MANAGER: /home/${{ secrets.EC2_SWARM_MANAGER_USER }}/app/scripts/docker-compose.prod.yml

jobs:
  #-------------------------
  # CI Job: Build & Push
  #-------------------------
  build_and_push:
    name: Build Docker Image and Push to Registry
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # Required to push to GHCR

    outputs:
      image_tag: ${{ steps.meta.outputs.version }} # Pass the generated tag to deploy job

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3.4.0
        with:
          username: ${{ secrets.REGISTRY_USER }} # Use secret for username
          password: ${{ secrets.REGISTRY_PASSWORD }} # Use secret for token/password

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          # images: ${{ env.IMAGE_NAME }}
          images: |
            tqt0304/apigateway
            tqt0304/eventservice
            tqt0304/userservice
            tqt0304/venueservice
            tqt0304/bookingservice
          tags: |
            # Use commit SHA for unique tagging (recommended)
            type=sha,prefix=sha-
            # Optionally, tag 'latest' on pushes to main branch
            type=raw,value=latest,enable={{is_default_branch}}

#      - name: Build and push Docker image (UserService)
#        uses: docker/build-push-action@v5
#        with:
#          context: .
#          file: ./UserService/Dockerfile
#          push: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }} # Push only on merge/push to main
#          tags: ${{ steps.meta.outputs.tags }}
#          labels: ${{ steps.meta.outputs.labels }}
#          cache-from: type=gha
#          cache-to: type=gha,mode=max
      - name: Build and push Docker image (EventService)
        uses: docker/build-push-action@v5
        with:
          context: . # Note: Context is different as per your compose file
          file: ./EventService/Dockerfile
          push: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
          tags: your-registry/eventservice:${{ steps.meta.outputs.version }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Docker image (UserService)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./UserService/Dockerfile
          push: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
          tags: your-registry/userservice:${{ steps.meta.outputs.version }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Docker image (VenueService)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./VenueService/Dockerfile
          push: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
          tags: your-registry/venueservice:${{ steps.meta.outputs.version }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Docker image (BookingService)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./BookingService.Api/Dockerfile
          push: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
          tags: your-registry/bookingservice:${{ steps.meta.outputs.version }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Echo Image Tag
        run: echo "Built image tag"

  #-------------------------------------
  # CD Job: Deploy to Swarm on EC2
  #-------------------------------------
  deploy_to_swarm_on_ec2:
    name: Deploy to Docker Swarm on EC2
    runs-on: ubuntu-latest
    needs: build_and_push # Depends on the build job

    # Only run this job on pushes to the main branch
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      # 1. Checkout code needed for the compose file
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Set up SSH agent (needed for scp and ssh action)
      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}

      # 3. Add Swarm Manager EC2 host to known_hosts
      - name: Add Swarm Manager EC2 host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.EC2_SWARM_MANAGER_HOST }} >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      # 4. NEW: Copy docker-compose.yml from Repo to Swarm Manager
      - name: Copy Compose file to Swarm Manager
        uses: appleboy/scp-action@v0.1.7 # Or use standard scp command
        with:
          host: ${{ secrets.EC2_SWARM_MANAGER_HOST }}
          username: ${{ secrets.EC2_SWARM_MANAGER_USER }}
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          source: "./scripts/docker-compose.prod.yml" # Path to compose file in your repo checkout
          target: "/home/${{ secrets.EC2_SWARM_MANAGER_USER }}/app" # Target directory on manager
          # Ensure target directory exists (create in SSH script below if needed)
          # strip_components: 1 # Use if your source path includes directories you don't want on target

      # 5. Deploy Stack via SSH to Swarm Manager (using the copied file)
      - name: Deploy Stack via SSH to Swarm Manager
        uses: appleboy/ssh-action@v1.0.3
        env:
            REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
            REGISTRY_USER: ${{ secrets.REGISTRY_USER }}
        with:
          host: ${{ secrets.EC2_SWARM_MANAGER_HOST }}
          username: ${{ secrets.EC2_SWARM_MANAGER_USER }}
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          envs: RDS_PASSWORD,RDS_USER,RDS_HOST,RDS_PORT,RDS_DB_NAME,REGISTRY_PASSWORD,REGISTRY_USER
          script: |
            set -e # Exit script on first error

            # --- Environment Variables for Deployment ---
            export DEPLOY_IMAGE_TAG=${{ needs.build_and_push.outputs.image_tag }}
            export APP_IMAGE_FULL_NAME=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${DEPLOY_IMAGE_TAG}
            export STACK_NAME=${{ env.SWARM_STACK_NAME }}
            # Use the path where the file was copied by scp
            export COMPOSE_FILE=${{ env.COMPOSE_FILE_PATH_ON_MANAGER }} # e.g., /home/ec2-user/app/docker-compose.yml

            # Environment variables for non-secret RDS config
            export RDS_HOST_ENV="${RDS_HOST}"
            export RDS_PORT_ENV="${RDS_PORT}"
            export RDS_DB_NAME_ENV="${RDS_DB_NAME}"

            export DB_USER_CONNECTION_STRING="${{ secrets.DB_USER_CONNECTION_STRING }}"
            export DB_VENUE_CONNECTION_STRING="${{ secrets.DB_VENUE_CONNECTION_STRING }}"
            export DB_BOOKING_CONNECTION_STRING="${{ secrets.DB_BOOKING_CONNECTION_STRING }}"
            export JWT_SECRET="${{ secrets.JWT_SECRET }}"
            export JWT_ISSUER="${{ secrets.JWT_ISSUER }}"
            export JWT_AUDIENCE="${{ secrets.JWT_AUDIENCE }}"
            export RABBITMQ_USER="${{ secrets.RABBITMQ_USER }}"
            export RABBITMQ_PASSWORD="${{ secrets.RABBITMQ_PASSWORD }}"
            export RABBITMQ_HOST="${{ secrets.RABBITMQ_HOST }}"
            export RABBITMQ_PORT="${{ secrets.RABBITMQ_PORT }}"
            export DB_HOST="${{secrets.DB_HOST}}"
            export DB_PORT="${{secrets.DB_PORT}}"
            export DB_USERNAME="${{ secrets.DB_USERNAME }}"
            export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            export DB_DATABASE= "${{ secrets.DB_DATABASE}}"
            export DB_SYNCHRONIZE= "${{ secrets.DB_SYNCHRONIZE}}"
            export NODE_ENV= "${{ secrets.NODE_ENV}}"
            export PORT= "${{ secrets.PORT}}"
            export IMAGE_TAG= "${{ steps.meta.outputs.version }}"
            export STACK_VERSION= "${{ secrets.STACK_VERSION}}"

            echo "--- Ensuring target directory exists ---"
            mkdir -p "$(dirname "${COMPOSE_FILE}")"

            echo "--- Logging into Docker Registry on Swarm Manager ---"
            echo "${REGISTRY_PASSWORD}" | docker login -u "${REGISTRY_USER}" --password-stdin

            # echo "--- Managing Docker Secrets for RDS Credentials ---"
            # echo "${RDS_PASSWORD}" | docker secret create --label swarm-stack=${STACK_NAME} rds_db_password - || echo "${RDS_PASSWORD}" | docker secret update rds_db_password -
            # echo "${RDS_USER}" | docker secret create --label swarm-stack=${STACK_NAME} rds_db_user - || echo "${RDS_USER}" | docker secret update rds_db_user -

            echo "--- Deploying Docker Stack Update using copied compose file ---"
            echo "Stack Name: ${STACK_NAME}"
            echo "Compose File: ${COMPOSE_FILE}" # This now points to the file copied via scp
            echo "Using Image: ${APP_IMAGE_FULL_NAME}"

            # Deploy the stack using the compose file transferred from the repo
            docker stack deploy --compose-file ${COMPOSE_FILE} ${STACK_NAME} --with-registry-auth

            echo "--- Deployment to Swarm on EC2 Completed ---"
